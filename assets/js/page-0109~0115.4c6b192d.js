(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{743:function(a,t,r){"use strict";r.r(t);var e=r(2),s=Object(e.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"_0109-0115"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_0109-0115"}},[a._v("#")]),a._v(" 0109 ~ 0115")]),a._v(" "),r("h2",{attrs:{id:"_0109-saga-패턴"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_0109-saga-패턴"}},[a._v("#")]),a._v(" 0109 - SAGA 패턴")]),a._v(" "),r("h3",{attrs:{id:"분산-트랜잭션-처리패턴"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#분산-트랜잭션-처리패턴"}},[a._v("#")]),a._v(" 분산 트랜잭션 처리패턴")]),a._v(" "),r("p",[a._v("MSA를 구성하면서 기능을 분리하고 저장소를 격리함에 따라 이전에 불거지지 않았던 문제가 발생한다. 즉, 여러개의 분산된 서비스에 걸쳐 비즈니스 처리를 수행해야 하는 경우 비즈니스 정합성 및 데이터 일관성을 어떻게 보장할 것인지 관한 문제를 다루기 위해 사용한다. 이렇게 여러 개의 분산된 서비스를 하나의 일관된 트랜잭션으로 묶는 것을 분산 트랜잭션 처리 패턴이라고 한다.")]),a._v(" "),r("h3",{attrs:{id:"saga-패턴"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#saga-패턴"}},[a._v("#")]),a._v(" SAGA 패턴")]),a._v(" "),r("p",[a._v("마이크로서비스들끼리 이벤트를 주고 받아 특정 마이크로서비스에서의 작업이 실패하면 이전까지의 작업이 완료된 마이크로서비스들에게 보상(complemetary) 이벤트를 소싱함으로써 분산 환경에서 원자성(atomicity)을 보장하는 패턴이다.")]),a._v(" "),r("h4",{attrs:{id:"choreography-based-saga-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#choreography-based-saga-pattern"}},[a._v("#")]),a._v(" "),r("strong",[a._v("[ Choreography based SAGA pattern ]")])]),a._v(" "),r("p",[a._v("Choreography-based Saga 패턴은 보유한 서비스 내의 로컬 트랜잭션을 관리하며 트랜잭션이 종료되면 완료 이벤트를 발행한다. 만약 그 다음 수행해야할 트랜잭션이 있으면 해당 트랜잭션을 수행해야하는 app으로 이벤트를 보내고, 해당 app은 완료 이벤트를 수신받고 다음 작업을 진행한다. 이를 순차적으로 수행하며 이때 이벤트는 Kafka와 같은 메시지 큐를 통해서 비동기 방식으로 전달할 수 있다."),r("br"),a._v("\n이 패턴에서는 각 app별로 트랜잭션을 관리하는 로직이 있다. 이를 통해 중간에 트랜잭션이 실패하면 해당 트랜잭션 취소 처리를 실패한 app에서 보상 이벤트를 발행해서 롤백처리를 시도한다.")]),a._v(" "),r("ul",[r("li",[a._v("구성하기 편하다.")]),a._v(" "),r("li",[a._v("트랜잭션의 현재 상태를 확인하기 어렵다.")])]),a._v(" "),r("h4",{attrs:{id:"orchestration-based-saga-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#orchestration-based-saga-pattern"}},[a._v("#")]),a._v(" "),r("strong",[a._v("[ Orchestration based SAGA pattern ]")])]),a._v(" "),r("p",[a._v("Orchestration-Based Saga 패턴은 트랜잭션 처리를 위해 Saga 인스턴스(Manager)가 별도로 존재한다. 트랜잭션에 관여하는 모든 app은 Manager에 의해 점진적으로 트랜잭션을 수행하며 결과를 Manager에게 전달하게 되고, 비지니스 로직상 마지막 트랜잭션이 끝나면 Manager를 종료해서 전체 트랜잭션 처리를 종료한다. 만약 중간에 실패시 Manager에서 보상 트랜잭션을 발동하여 일관성을 유지한다."),r("br"),a._v("\n해당 패턴은 모든 관리를 Manager가 호출하기 떄문에 분산트랜잭션의 중앙 집중화가 이루어진다.")]),a._v(" "),r("ul",[r("li",[a._v("서비스간의 복잡성이 줄어들어서 구현 및 테스트가 쉬워진다.")]),a._v(" "),r("li",[a._v("트랜잭션의 현재 상태를 Manager가 알고 있으므로 롤백하기 쉽다.")]),a._v(" "),r("li",[a._v("관리를 해야하는 Orchestrator 서비스가 추가되어야하기 때문에 인프라 구현이 복잡해진다.")])])])}),[],!1,null,null,null);t.default=s.exports}}]);